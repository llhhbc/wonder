<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on miracle of light</title>
    <link>http://wonder.zxcsoft.com/post/</link>
    <description>Recent content in Posts on miracle of light</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Sun, 22 Jul 2018 20:01:00 +0800</lastBuildDate>
    
	<atom:link href="http://wonder.zxcsoft.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>goadesign 学习之adder</title>
      <link>http://wonder.zxcsoft.com/post/goa/goa_use/</link>
      <pubDate>Sun, 22 Jul 2018 20:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/goa/goa_use/</guid>
      <description>goadesign 学习  一次接触中，了解到了goa，根据dsl做巧妙的翻译，自动完成统一代码的生成
 github上搜索goadesign，可以看到他有的代码库，出于学习，我把它的样例库下载下来了，我决定从样例代码开始，结合官方的文档来学习
先从第一个例子开始  第一个是加法服务，adder目录只有两个go文件，其中一个还在报错（其实是程序自动生成的文件，只是里面有自己定制的代码，所以保留了  // adder/design/design.go var _ = API(&amp;quot;adder&amp;quot;, func() { //api定义说明，一个文件只可以有一个api Title(&amp;quot;The adder API&amp;quot;) Description(&amp;quot;A teaser for goa&amp;quot;) Host(&amp;quot;localhost:8080&amp;quot;) Scheme(&amp;quot;http&amp;quot;) }) var _ = Resource(&amp;quot;operands&amp;quot;, func() { //资源说明，resource对应一个service Action(&amp;quot;add&amp;quot;, func() { //动作说明，api请求动作 Routing(GET(&amp;quot;add/:left/:right&amp;quot;)) //定义访问地址格式 Description(&amp;quot;add returns the sum of the left and right parameters in the response body&amp;quot;) Params(func() { //定义请求url中参数说明 Param(&amp;quot;left&amp;quot;, Integer, &amp;quot;Left operand&amp;quot;) Param(&amp;quot;right&amp;quot;, Integer, &amp;quot;Right operand&amp;quot;) }) Response(OK, &amp;quot;text/plain&amp;quot;) //定义应答报文样式 }) })   根据design文件生成代码  goagen bootstrap -d github.</description>
    </item>
    
    <item>
      <title>golang 总结</title>
      <link>http://wonder.zxcsoft.com/post/language/go/quest/</link>
      <pubDate>Wed, 18 Jul 2018 20:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/language/go/quest/</guid>
      <description> Ready go 1. goroutine  goroutine 对应的用户态线程，而不是系统线程，调度是由golang自己来调度的 golang采用的是一种多对多的方案，m个用户线程对应n个系统线程 golang有3个角色：  M：代表系统线程，由操作系统管理 G：goroutine的实体，包括的调用栈，重要的调度信息 P：衔接M和G的调度上下文，由GOMAXPROCS决定，一般和核心数对应。每个P会将goroutine从一个就绪的队列中做pop操作，为了减小锁的竞争，通常情况下每个P会负责一个队列   </description>
    </item>
    
    <item>
      <title>读《微服务架构与实践》总结</title>
      <link>http://wonder.zxcsoft.com/post/book/micro/</link>
      <pubDate>Tue, 17 Jul 2018 20:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/book/micro/</guid>
      <description> 微服务的特征  业务独立性 轭人自主性 单一职责 轻量级通信
 服务作为组件
 围绕业务组织团队
 关注产品而非项目
 技术多样性
 业务数据独立
 基础设施自动化
 演进式架构
  构建微服务考虑的问题  任务拆分
尽早将开发、测试、部署、运维、监控的流水线打通，才能帮助团队更好的驾驭微服务
 同一时间聚焦一个任务 能对每次完成的部分做持续集成 整体的进度容易追踪  一般任务分为如下几个过程： * 服务实现 * 代码测试与静态检查 * Docker镜像构建 * docker镜像部署 * 功能迭代 * 日志聚合 * 监控与告警 * 持续集成与交付
  微服务设计 开发  独立代码库 服务说明文件  服务介绍 服务维护者 服务可用期 定义环境：生产环境、类生产环境、测试环境 开发说明：如果搭建开发环境、如何运行服务、如何定位问题 测试说明：测试策略、如何运行测试、如果查看测试结果 构建说明：集成访问的url、集成流程描述、构建的部署包 部署说明：如何部署到不同环境、部署后功能验证 运维说明：日志聚合的访问、告警信息的访问、监控信息的访问  代码所有权归团队：不能让代码只有一个人熟悉 有效的代码版本管理 代码静态检查工具 代码易于本地运行  测试  接口测试 测试的有效性  构建  每个服务都是一个可独立部署的业务单元  部署  部署环境说明  运维  监控 告警 日志聚合  微服务之前的通讯  同步通讯、异步通讯 rpc rest：资源、表述、状态转移、统一接口  get用来获取资源 post来新建资源 put来更新资源 delete来删除资源  hal  基于rest，但把每个资源分成三部分：状态、链接、子资源  消息队列  </description>
    </item>
    
    <item>
      <title>caddy</title>
      <link>http://wonder.zxcsoft.com/post/tools/caddy-src/</link>
      <pubDate>Fri, 29 Jun 2018 20:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/tools/caddy-src/</guid>
      <description> caddy  caddy是个网站搭建工具  </description>
    </item>
    
    <item>
      <title>gorm源码分析</title>
      <link>http://wonder.zxcsoft.com/post/gorm/gorm-src/</link>
      <pubDate>Wed, 27 Jun 2018 20:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/gorm/gorm-src/</guid>
      <description>总体分析  使用gorm的过程中，觉得它写的有意思，想了解下它的实现原理，所以就分析下源代码
 源码分析  由于这个是个库，并没有执行程序，看到目录下有main.go，所以就从这个开始
  main   定义了DB结构：
 Value //是接口类型，可放任何数据 Error //是记录错误 RowsAffected //记录生效行数 //单个db私有属性 db //定义的公共接口（Exec，Prepare，Query，QueryRow） //暂时不明白为什么选这4个，从open中可看出，go标准库中的sql.DB是实现了这个接口的 blockGlobalUpdate //记录全局更新标志 //从BlockGlobalUpdate函数中可看出，这个标志为true时，update或者delete没有where时，会报错 logMode //日志开关 2打开，1关闭 logger //自定义日志接口(print) search //search结构指针（用来拼接sql语句的） values //map[string]interface{} 可保存任何东西的map，暂时不知道要保存什么 //全局db属性 parent //父DB对象 callbacks //回调结构指针（记录了creates,updates,deletes,queries,rowQueries,processors类型的回调函数切片） dialet //sql格式化接口（针对不同的数据库定制化的差异） singularTable //bool类型，暂时不知道干什么的   open函数，调用go标准库打开数据库连接，设置默认日志，默认回调函数，并根据数据库连接类型，设置sql格式对象，并调用ping测试连接
后面就是一些DB的常规set和get方法，还有就是拼接sql的方法 * 通过set函数，可以看到，values里面保存的单个db中的修改化配置，clone的时候会复制过去，不是共用
main 大致过了一遍，对整个有点了解，再回看目录下的文件：
1. association 处理表关系的，针对外键 2. callback 开头的文件，处理回调函数的（等会重点看的） 3. dialect 开头的文件，处理各种数据库之前语法差异的 4. errors 定义了错误管理，所有的错误都在切片中 5. interface 定义了公共类的接口 6.</description>
    </item>
    
    <item>
      <title>es 基本使用</title>
      <link>http://wonder.zxcsoft.com/post/es/esuse/</link>
      <pubDate>Mon, 25 Jun 2018 20:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/es/esuse/</guid>
      <description></description>
    </item>
    
    <item>
      <title>golang pprof使用</title>
      <link>http://wonder.zxcsoft.com/post/language/go/pprof/</link>
      <pubDate>Mon, 28 May 2018 20:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/language/go/pprof/</guid>
      <description>启用pprof  带有http的服务，只需要引入 import _ &amp;quot;net/http/pprof&amp;quot; 就可以通过访问http://ip:port/debug/pprof 查看了
 没有http服务的应用，或者不想在原端口启用的，可像我这样实现根据配置启用（config是我自定义的配置包）
  import ( _ &amp;quot;net/http/pprof&amp;quot; &amp;quot;net/http&amp;quot; ) func InitModel() { var ppaddr string if config.HasModuleInit() { ppaddr = config.StringDefault(&amp;quot;ppaddr&amp;quot;, &amp;quot;&amp;quot;) if ppaddr != &amp;quot;&amp;quot; { go http.ListenAndServe(ppaddr, nil) } } }  pprof使用 1.代码优化 curl http://ip:port/debug/pprof/profile &amp;gt; /tmp/a.profile go tool pprof 可执行程序 /tmp/a.profile (pprof) top #可查看占用资源最多的函数  pprof各字段的含义依次是：  采样点执行时间 采样点落在该函数中的百分比 上一项的累积百分比 采样点落在该函数，以及被它调用的函数执行的总时间 采样点落在该函数，以及被它调用的函数中的百分比 函数名 文件名  pprof分析  / 访问根目录，里面有几个链接：</description>
    </item>
    
    <item>
      <title>记忆基数</title>
      <link>http://wonder.zxcsoft.com/post/selfupd/memorybase/</link>
      <pubDate>Wed, 16 May 2018 19:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/selfupd/memorybase/</guid>
      <description> 记忆基数  1 粉笔 2 鸭子 3 耳朵 4 红旗 5 秤钩 6 口哨 7 锄头 8 葫芦 9 气球 10 老师 11 双截棍 12 不倒翁 13  </description>
    </item>
    
    <item>
      <title>python 简单使用</title>
      <link>http://wonder.zxcsoft.com/post/language/python/pythi/</link>
      <pubDate>Fri, 11 May 2018 20:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/language/python/pythi/</guid>
      <description>ipynb
jupyter notebook  </description>
    </item>
    
    <item>
      <title>tensorFlow 入门</title>
      <link>http://wonder.zxcsoft.com/post/tensorflow/learn_tensor/</link>
      <pubDate>Fri, 11 May 2018 20:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/tensorflow/learn_tensor/</guid>
      <description> 环境搭建 pyenv搭建 1.安装pyenv 1.安装pip virtualenv 1.创建虚拟环境 python3 -m venv ./env 1.切换环境 . env/bin/activate
conda搭建 1.安装anaconda3 1.创建虚拟环境 conda create --name py3 python=3 1.环境切换 source activate py3
tensorflow安装(下面操作都在python3环境下操作) ##我本地环境如下搭建 # conda create --name mytensor python=3.6 # source activate mytensor # source deactivate #退出环境 pip install tensorflow pip install tensorlayer  验证环境安装 import tensorflow as tf hello = tf.constant(&amp;quot;hello, tensorflow&amp;quot;) sess = tf.Session() print(sess.run(hello))  简单入门  参考资料 中文社区     类型 描述 说明     session 会话 一次流程执行的会话，包含上下文信息   graph 描述计算过程 在session中启动，图形显示   tensor 数据 数据类型   op 操作 数据之间的操作   variable 变量 数据类型，运行中可改变，用于维护状态   feed 赋值 为op的tensor赋值   fetch 取值 从op的tensor中取值   constant 常量     </description>
    </item>
    
    <item>
      <title>学习汇总</title>
      <link>http://wonder.zxcsoft.com/post/allmywonder/</link>
      <pubDate>Thu, 10 May 2018 20:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/allmywonder/</guid>
      <description> 学习汇总 语言学习  go c php python java  go  kubernetes etcd istio tensorflow hugo grafana influxdb consul prometheus appdash nomad hystrix &amp;ndash; gin
 kit
 hydra
  php  laravel  python  tensorflow pytorch deepmind lab  js  nodejs codecombat  想做的事  读懂v8，用go来实现 使用tensorflow，完成智能识别 训练记忆力 es做为存储，d3来展示，完成思维图的整理与知识分析 使用kuber完成思维系统的搭建  </description>
    </item>
    
    <item>
      <title>es 入门</title>
      <link>http://wonder.zxcsoft.com/post/es/esstart/</link>
      <pubDate>Fri, 27 Apr 2018 09:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/es/esstart/</guid>
      <description> es安装  官网下载 es https://www.elastic.co/downloads/elasticsearch ```shell unzip elasticsearch-6.2.4.zip cd elasticsearch-6.2.4/config  #修改集群名字和端口,数据目录等 vi elasticsearch.yml
启动es cd elasticsearch-6.2.4/bin ./elasticsearch
验证启动状态 curl http://127.0.0.1:9200
### 安装中文分词 &amp;gt; 参考 https://github.com/medcl/elasticsearch-analysis-ik &amp;gt; ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip ### es简单使用 #### 创建一个index mapping（相当于一个表） ```shell curl -XPUT &#39;localhost:9200/wonderbook?pretty&#39; -H &#39;Content-type:application/json&#39; -d &#39; { &amp;quot;mappings&amp;quot;: { &amp;quot;articles&amp;quot;: { &amp;quot;properties&amp;quot;: { &amp;quot;title&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;, &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;}, &amp;quot;description&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;, &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;}, &amp;quot;tags&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;, &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;}, &amp;quot;date&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;date&amp;quot;}, &amp;quot;categories&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;, &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;}, &amp;quot;context&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;, &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;} } } } } &#39;  </description>
    </item>
    
    <item>
      <title>kbuernetes 学习</title>
      <link>http://wonder.zxcsoft.com/post/kuber/learn_kuber/</link>
      <pubDate>Fri, 27 Apr 2018 09:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/kuber/learn_kuber/</guid>
      <description>Kubernetes基本概念 Pod Pod是一组容器集合，他们共享IPC、Network 和 UTC namespace 例：
apiVersion: v1 kind: Pod metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80  Node 运行pod的主机
Namespace 管理一组资源和对象
Service 应用服务的抽象，通过labels为应用提供负载均衡和服务发现。匹配labels为Pod IP和端口列表组成endpoints，由kube-proxy负责将服务IP负载均衡到这些endpoints上。 每个Service都会自动分配一个culster IP（仅在集群内部可访问的虚拟地址）和DNS名，其它容器可以通过该地址或DNS来访问服务
apiVersion: v1 kind: Service metadata: name: nginx spec: ports: - port: 8078 name: http targetPort: 80 protocol: TCP selector: app: nginx  Label 是识别Kurbernetes对象的标签，以key/value的方式附加到对象上。Label不提供唯一性，经常是很多对象（如Pods）都使用相同的label来标志具体的应用（如负载均衡时结点为的选择） label选择支持如下模式： * 等式： app=nginx 或 env!= production * 集合: env in (production, qa) * 多个label（他们之间是AND的关系）： app=nginx,env=test</description>
    </item>
    
    <item>
      <title>linux下socket的复用</title>
      <link>http://wonder.zxcsoft.com/post/linux/linux_socket/</link>
      <pubDate>Fri, 27 Apr 2018 09:01:00 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/linux/linux_socket/</guid>
      <description> linux下端口复用 SO_REUSEADDR可以用在以下四种情况下。 (摘自《Unix网络编程》卷一，即UNPv1)  当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。
 SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。
 SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。
 SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。
  </description>
    </item>
    
    <item>
      <title>istio初尝试</title>
      <link>http://wonder.zxcsoft.com/post/kuber/istio/</link>
      <pubDate>Thu, 26 Apr 2018 20:46:49 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/kuber/istio/</guid>
      <description>说明  参考 http://istio.doczh.cn/
 安装istio  kubectl apply -f install/kubernetes/istio.yaml #如果出现 unable to recognize &amp;ldquo;install/kubernetes/istio.yaml&amp;rdquo; 的错误，删除后再重新执行一遍就好了
 部署bookinfo kubectl apply -f &amp;lt;(istioctl kube-inject -f bookinfo.yaml) #获取访问地址 export GATEWAY_URL=$(kubectl get po -l istio=ingress -n istio-system -o &#39;jsonpath={.items[0].status.hostIP}&#39;):$(kubectl get svc istio-ingress -n istio-system -o &#39;jsonpath={.spec.ports[0].nodePort}&#39;) #测试地址访问 curl -o /dev/null -s -w &amp;quot;%{http_code}\n&amp;quot; http://${GATEWAY_URL}/productpage  1.1 验证路由访问 #所有用户都访问v1 istioctl create -f route-rule-all-v1.yaml #jason用户登录访问v2 istioctl create -f route-rule-reviews-test-v2.yaml  1.2 记录日志 ##保存如下信息为 new_telemetry.</description>
    </item>
    
    <item>
      <title>kuber手工搭建</title>
      <link>http://wonder.zxcsoft.com/post/kuber/kuber_onebyone/</link>
      <pubDate>Thu, 26 Apr 2018 20:46:49 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/kuber/kuber_onebyone/</guid>
      <description>准备工作 关闭selunix 关闭swap 作为node的结点，要安装docker（包括master和node共用的）
 设置主机名 &amp;gt; sh etc/set_hosts.sh
 安装etcd &amp;gt; sh rpms/install_etcd.sh
 安装etcd证书 &amp;gt; sh keys/etcd/install_etc_key.sh
 修改etcd配置 &amp;gt; sh etc/set_etcd.sh
 启动etcd &amp;gt; sh run/start_etcd.sh
 安装kube 程序 &amp;gt; sh rpms/install_kuber.sh
 安装kuber证书 &amp;gt; sh keys/k8s/install_k8s_key.sh
 修改kuber配置 &amp;gt; #设置master结点 &amp;gt; sh etc/kube_cfg/set_kuber_cfg.sh &amp;gt; #设置node结点 &amp;gt; sh etc/kube_cfg/set_kuber_node_cfg.sh &amp;gt; #如果master也作为node结点，则运行 &amp;gt; sh etc/kube_cfg/set_kuber_master_node_cfg.sh
 启动kube &amp;gt; sh run/start_kube.sh &amp;gt; #在任意一台master上执行： 开启认证 &amp;gt; kubectl create clusterrolebinding kubelet-bootstrap &amp;ndash;clusterrole=system:node-bootstrapper &amp;ndash;user=kubelet-bootstrap &amp;gt; #如果master上要启动作为node，则 &amp;gt; sh run/start_kube_master_node.</description>
    </item>
    
    <item>
      <title>kuberadm start</title>
      <link>http://wonder.zxcsoft.com/post/kuber/kubeadm_start/</link>
      <pubDate>Thu, 26 Apr 2018 10:46:49 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/kuber/kubeadm_start/</guid>
      <description>kubernetes搭建比较复杂，所以选择先用kubeadm全自动来先试试手（奈何墙有点高，所以加了些插曲）
通过kubeadm安装 参考 官方文档
1. 准备环境 1.1 修改hostname  修改 /etc/hostname  1.2 关闭sellinux，关闭防火墙  setenforce 0 编辑/etc/selinux/config
 firewall-cmd &amp;ndash;state 查看状态
 systemctl stop firewalld.service # 停止firewall
 systemctl disable firewalld.service # 禁止firewall开机启动
  1.3 关闭swap swapoff -a 编辑 /etc/fstab 去掉swap配置（#号注释掉）  1.4 安装crictl (可选) go get github.com/kubernetes-incubator/cri-tools/cmd/crictl GOARCH=amd64 GOOS=linux go build  1.5 get docker image  运行kubeadm init 当提示请稍等后，检查/etc/kubernetes/manifests 目录下的yaml文件，里面会有需要的镜像和版本 通过hub.docker.com 中转，实现镜像的下载 具体方法请参考：kubeadm搭建（by mritd） 重新tag镜像(以下是我使用的，可直接pull后使用)</description>
    </item>
    
    <item>
      <title>kube问题汇总</title>
      <link>http://wonder.zxcsoft.com/post/kuber/kube_help/</link>
      <pubDate>Thu, 26 Apr 2018 10:46:49 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/kuber/kube_help/</guid>
      <description> 虚拟机建议用virutalbox
当时istio的bookinfo无法部署： reviews-v2-7bdf9b96b6-khg7s 老是会报错，提示无法创建目录，没权限，后来查是虚拟机sandbox版本太低，导致的一个bug，文件无法删除也无法修改
 virtualbox建议用nat 网络的方式，自己添加一个网卡，作为虚拟机集群的网络
然后每个主机在加一个hostonly的网卡，用于主机访问虚拟机
 硬盘没空间：
突然发现pod状态变成了：Evicted，还有挂起的，然后 通过 kubelet describe命令查看，发现是node空间满了，无法部署了：我看空间用了80%
 时间不同步：
时间不同步时，会出现 Unable to authenticate the request due to an error: x509: certificate has expired or is not yet valid 我同步机器时间后，问题解决。。。
 token不一致：
配置文件bootstrap.kubeconfig中token不一致，会导致这个错 failed to run Kubelet: cannot create certificate signing request: Unauthorized
  </description>
    </item>
    
    <item>
      <title>open source list</title>
      <link>http://wonder.zxcsoft.com/post/source_list/</link>
      <pubDate>Thu, 26 Apr 2018 10:38:52 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/source_list/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Learn markdown</title>
      <link>http://wonder.zxcsoft.com/post/learn-md/</link>
      <pubDate>Wed, 25 Apr 2018 12:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/learn-md/</guid>
      <description>标题  利用=（最高阶标题） 和 - （第二阶标题） 在行首插入1到6个#，对应标题1到6阶  区块使用  在每行前面，或者段落最前面加上&amp;gt; 表示区块引用,如：   aa
 aa dsafas
  列表  用星号、加号或减号来表示无序列表 用数字加英文句点（不在乎数字是几）表示有序列表，数字会重新自动生成  代码区块  缩进4个空格或者一个制表符，就是代码区块 如果段内有一小段代码，可以用`号包起来，如  printf();   如果代码中也有`号，可以用多个来标记开始和结束如：  printf(&amp;quot;`&amp;quot;);   引用一段代码, 如：引用部分c++代码  int a=1; int b=2; int c= a+b;  分隔线  在一行中用3个以上的星号、减号、底线来建立一个分隔线  链接  链接文字用[方括号]来标记，后面紧接着用圆括号闰插入网上链接 如：test link 链接标记： 两个方括号 test link 前一个是链接文字，后一个是标记，然后在后面标记这个id  强调  使用星号、底线 作为标志强调字词的符号 （用一个*或_包围的字词会转成EM标签，用两个会转成strong this is em this is strong  图片  添加图片 !</description>
    </item>
    
    <item>
      <title>grafana源码学习</title>
      <link>http://wonder.zxcsoft.com/post/grafana/grafana-src/</link>
      <pubDate>Wed, 25 Apr 2018 12:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/grafana/grafana-src/</guid>
      <description>grafana学习 1.整体流程了解 grafana-server(从main开始)  根据profile标志判断是否开启pprof 初始化版本、时间缀信息 初始化metrics包的版本信息
 在prometheus 中记录版本值1  创建grafanaServer
 init加载的清单
 api  通过registry.RegisterService注册http服务：HTTPServer  log  创建根root日志对象  login  在bus上注册句柄：&amp;rdquo;auth&amp;rdquo;, UpsertUser 扩展用户管理  setting
 记录系统标志（是否是windows）  extensions
 errors 引入github.com/pkg/errors包，在出错时，会记录栈信息，还有详细的函数信息  metrics
 初始化prometheus统计变量  plugins
 通过registry.RegisterService注册插件管理器：PluginManager  type Service interface { Init() error }  所有的插件都实现这个接口 在bus上注册句柄：&amp;rdquo;plugins&amp;rdquo;：ImportDashboard 在bus上注册事件监听：handlePluginStateChanged  services/alerting
 在bus上注册句柄：&amp;rdquo;alerting&amp;rdquo;, updateDashboardAlerts 在bus上注册句柄：&amp;rdquo;alerting&amp;rdquo;, validateDashboardAlerts 通过registry.RegisterService注册告警服务：AlertingService 在bus上注册句柄：&amp;rdquo;alerting&amp;rdquo;, handleNotificationTestCommand 在bus上注册句柄：&amp;rdquo;alerting&amp;rdquo;, handleAlertTestCommand  services/cleanup</description>
    </item>
    
    <item>
      <title>use hugo</title>
      <link>http://wonder.zxcsoft.com/post/hugo/use-hugo/</link>
      <pubDate>Wed, 25 Apr 2018 12:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/hugo/use-hugo/</guid>
      <description> hugo的安装 go get github.com/gohugoio/hugo  基本使用  创建一个网站项目 hugo new site hello 安装一个theme hugo将数据和展示分开了，显示部分由theme来管理 原理如下：  项目下的数据，会由hugo按格式读取，并约定好模板中的变更名，由theme来显示出来 比如：.Data表示content下的页面信息 theme就是go用来渲染的模板，而项目下content下的就是它的数据来源（默认用这个目录），也支持用其它目录   发布github  github上新创建一个repository 修改本地baseurl为github的：https://llhhbc.github.io/wonder/ 上传代码：  hugo ##生成静态文件 cd public git init git add . git commit -m &amp;quot;init&amp;quot; git remote add github https://github.com/llhhbc/wonder.git git push github master   在repository 的设置（setting）中，找到github pages 在source中选择分支，点击save（会自动刷新，然后会提示访问地址）  </description>
    </item>
    
    <item>
      <title>use hugo</title>
      <link>http://wonder.zxcsoft.com/post/use-hugo/</link>
      <pubDate>Wed, 25 Apr 2018 12:02:28 +0800</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/use-hugo/</guid>
      <description> hugo的安装 go get github.com/gohugoio/hugo  基本使用  创建一个网站项目 hugo new site hello 安装一个theme hugo将数据和展示分开了，显示部分由theme来管理 原理如下：  项目下的数据，会由hugo按格式读取，并约定好模板中的变更名，由theme来显示出来 比如：.Data表示content下的页面信息 theme就是go用来渲染的模板，而项目下content下的就是它的数据来源（默认用这个目录），也支持用其它目录   发布github  github上新创建一个repository 修改本地baseurl为github的：https://llhhbc.github.io/wonder/ 上传代码：  hugo ##生成静态文件 cd public git init git add . git commit -m &amp;quot;init&amp;quot; git remote add github https://github.com/llhhbc/wonder.git git push github master   在repository 的设置（setting）中，找到github pages 在source中选择分支，点击save（会自动刷新，然后会提示访问地址）  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://wonder.zxcsoft.com/post/des/des_pin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/des/des_pin/</guid>
      <description>pin des PIN 明文：123456 磁卡上的PAN：1234 5678 9012 3456 78 截取下的PAN：6789 0123 4567 则用于PIN加密的PAN为：0x00 0x00 0x67 0x89 0x01 0x23 0x45 0x67 则PIN BLOCK为： 0x06 0x12 0x34 0x56 0xFF 0xFF 0xFF 0xFF 异或：0x00 0x00 0x67 0x89 0x01 0x23 0x45 0x67 结果为：0x06 0x12 0x53 0xDF 0xFE 0xDC 0xBA 0x98</description>
    </item>
    
    <item>
      <title></title>
      <link>http://wonder.zxcsoft.com/post/prometheus/prometheus-src/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://wonder.zxcsoft.com/post/prometheus/prometheus-src/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>